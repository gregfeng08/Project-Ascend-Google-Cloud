<!doctype html>
<meta charset="utf-8" />
<title>Client</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<link rel="stylesheet" href="https://use.typekit.net/ake2rry.css">
<style>
  :root { color-scheme: light dark; }
  html, body { height: 100%; margin: 0; }
  body {
    display:flex; align-items:center; justify-content:center;
    background:#111; color:#eee; font-family:"bitcount-mono-double-square", system-ui; font-weight:400; font-style:normal;
    padding: env(safe-area-inset-top) 8px env(safe-area-inset-bottom);
  }
  #wrap { width: 100%; max-width: 900px; text-align: center; position: relative; }
  canvas { background:#1e1e1e; border:1px solid #333; border-radius:12px; touch-action: manipulation; }

  /* Connection indicator */
  #connStatus {
    position: absolute;
    top: 8px; right: 12px;
    display: flex; align-items: center; gap: 6px;
    font-size: 14px; opacity: .9;
    user-select: none;
  }
  #connDot {
    width: 12px; height: 12px;
    border-radius: 50%;
    background-color: red;
    box-shadow: 0 0 4px rgba(0,0,0,.5);
  }
  @keyframes pulseRed {
    0%   { background-color: #900; transform: scale(1);   box-shadow: 0 0 6px #f00; }
    50%  { background-color: #f00; transform: scale(1.3); box-shadow: 0 0 10px #f55; }
    100% { background-color: #900; transform: scale(1);   box-shadow: 0 0 6px #f00; }
  }
  .pulse { animation: pulseRed 1.2s infinite ease-in-out; }

  .hint { opacity:.85; font-size:14px; margin-top:8px; }
</style>

<div id="wrap">
  <div id="connStatus">
    <div id="connDot"></div><span id="connText">Connecting…</span>
  </div>
  <h1 style="margin:0 0 8px;">Client</h1>
  <p>Server scene: <strong id="serverScene">Waiting</strong></p>
  <p>Your class: <strong id="classEl">not selected</strong></p>
  <canvas id="canvas" width="600" height="400"></canvas>
  <p id="help" class="hint">Enter your name, then choose a class to join.</p>
  <p id="status" style="opacity:.7;margin-top:10px;">&nbsp;</p>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const connDot  = document.getElementById("connDot");
  const connText = document.getElementById("connText");
  const statusEl = document.getElementById("status");
  const serverSceneEl = document.getElementById("serverScene");
  const classLabel = document.getElementById("classEl");
  const help = document.getElementById("help");

  const CLASS_NAMES = {
    1: "Bard",
    2: "Druid",
    3: "Rogue",
    4: "Wizard",
    5: "Paladin",
  };
  const CLASS_ORDER = [1,2,3,4,5];

  var internalCtr = {obedience:0,selfishness:0,sacrifice:0};

  const socket = io();
  socket.emit("identify", { role: "client" });

  // Connection indicator behavior
  socket.on("connect", () => {
    connDot.style.backgroundColor = "limegreen";
    connDot.classList.remove("pulse");
    connText.textContent = "Connected";
    statusEl.textContent = "Connected: " + socket.id;
  });
  socket.on("disconnect", () => {
    connDot.style.backgroundColor = "#900";
    connDot.classList.add("pulse");
    connText.textContent = "Disconnected — retrying…";
    statusEl.textContent = "Disconnected… (auto-retrying)";
  });
  socket.on("reconnect", (attempt) => {
    connDot.style.backgroundColor = "limegreen";
    connDot.classList.remove("pulse");
    connText.textContent = "Reconnected (attempt " + attempt + ")";
    setTimeout(() => connText.textContent = "Connected", 2000);
  });

  // Client local pipeline: Title -> ClassSelect -> Waiting
  let localStage = "Title";
  let displayName = "";
  let userClass = null;

  // Scenes + meta from server
  let sceneList = [];   // [{index,name,type,question,flavor}, ...]
  let serverScene = "Waiting";
  let serverIndex = 0;

  // Voting state
  let hasVoted = false;
  let sceneOptions = [];
  let allowedClasses = [];
  let currentSceneData = null;
  let sceneQuestionOverride = null;
  let classPickerIndex = 0;

  // Timer
  let timerRemainingMs = 0;
  let timerDurationMs  = 30_000;

  // Receive scenes (with meta)
  socket.on("scenes", ({ scenes }) => {
    sceneList = scenes.slice();
  });

  // Title name set
  socket.on("nameSet", ({ ok, name }) => { if (ok) { displayName = name || ""; render(); } });

  // Class select
  socket.on("classSet", ({ classId }) => {
    userClass = classId;
    syncPickerToUser();
    const name = CLASS_NAMES[classId] || `Class ${classId}`;
    classLabel.textContent = name;
    localStage = "Waiting";
    help.textContent = `You are a ${name}. Waiting for the show to start…`;
    socket.emit("joinAfterClass");
    applySceneDataForUser();
    render();
  });

  // State updates (include index so we can read flavor/question)
  socket.on("state", ({ state, index }) => {
    const prevScene = serverScene;
    serverScene = state; 
    serverIndex = Number.isInteger(index) ? index : serverIndex;
    serverSceneEl.textContent = state;

    if (state === "EndScene") {
      localStage = "EndScene";
    } else if (localStage === "EndScene") {
      localStage = "Waiting";
    }

    if (state !== prevScene) {
      hasVoted = false;
      currentSceneData = null;
      sceneQuestionOverride = null;
      sceneOptions = [];
      allowedClasses = [];
    } else if (localStage === "Waiting" && isVoting(serverScene)) {
      hasVoted = false;
    }

    render();
  });

  function copyList(list){ return Array.isArray(list) ? list.slice() : []; }
  function findGroupForUser(data){
    if (!data || !Array.isArray(data.groups) || !userClass) return null;
    return data.groups.find(g => Array.isArray(g.allowedClasses) && g.allowedClasses.includes(userClass)) || null;
  }
  function currentPickerClass(){
    return CLASS_ORDER[classPickerIndex] || CLASS_ORDER[0];
  }
  function syncPickerToUser(){
    if (userClass && CLASS_ORDER.includes(userClass)) {
      classPickerIndex = CLASS_ORDER.indexOf(userClass);
    } else if (classPickerIndex < 0 || classPickerIndex >= CLASS_ORDER.length) {
      classPickerIndex = 0;
    }
  }
  function applySceneDataForUser(){
    if (!currentSceneData || currentSceneData.name !== serverScene) return;
    if (currentSceneData.multi) {
      const group = findGroupForUser(currentSceneData);
      if (group) {
        sceneOptions = Array.isArray(group.options) ? group.options.slice() : [];
        allowedClasses = copyList(group.allowedClasses);
        sceneQuestionOverride = group.question || null;
      } else {
        sceneOptions = [];
        allowedClasses = copyList(currentSceneData.allowedClasses);
        sceneQuestionOverride = currentSceneData.name === "DruidRogueTrial"
          ? "filler text DruidRogue"
          : null;
      }
    } else {
      sceneOptions = Array.isArray(currentSceneData.options) ? currentSceneData.options.slice() : [];
      allowedClasses = copyList(currentSceneData.allowedClasses);
      sceneQuestionOverride = currentSceneData.question || null;
    }
  }

  socket.on("sceneData", (payload) => {
    if (payload.name !== serverScene) return;
    currentSceneData = payload;
    applySceneDataForUser();
    render();
  });

  socket.on("sceneReset", ({ scene }) => {
    if (scene === serverScene) { hasVoted = false; render(); }
  });

  socket.on("timer", ({ remainingMs, durationMs }) => {
    timerRemainingMs = remainingMs; timerDurationMs = durationMs; render();
  });

  socket.on("notEligible", ({ scene, required }) => {
    if (scene === serverScene) {
      const pretty = required.map(c => CLASS_NAMES[c] || c).join(", ");
      help.textContent = `Not eligible. Allowed classes: ${pretty}`;
      setTimeout(() => { if (help.textContent.startsWith("Not eligible")) help.textContent = ""; }, 2500);
    }
  });

  function isVoting(name){
    return name !== "Waiting" && name !== "EndScene";
  }

  // Canvas + layout
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const ASPECT = 3/2;

  function getViewportSize(){
    const vv = window.visualViewport;
    return { vw: vv ? vv.width : innerWidth, vh: vv ? vv.height : innerHeight };
  }
  function resizeCanvasToViewport(){
    const { vw, vh } = getViewportSize();
    const maxW = Math.min(vw * 0.98, 900);
    const maxH = Math.min(vh * 0.92, 900);
    let cssW = maxW, cssH = cssW / ASPECT;
    if (cssH > maxH) { cssH = maxH; cssW = cssH * ASPECT; }
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    fitForDPR(); render();
  }
  function fitForDPR(){
    const dpr = devicePixelRatio || 1;
    const cssW = canvas.clientWidth || canvas.width;
    const cssH = canvas.clientHeight || canvas.height;
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  let rafReq = null;
  function scheduleResize(){
    if (rafReq) return;
    rafReq = requestAnimationFrame(() => { rafReq = null; resizeCanvasToViewport(); });
  }
  addEventListener("resize", scheduleResize, { passive:true });
  if (visualViewport){
    visualViewport.addEventListener("resize", scheduleResize, { passive:true });
    visualViewport.addEventListener("scroll", scheduleResize, { passive:true });
  }

  // Drawing helpers
  function clear(){
    const w = canvas.clientWidth || 600, h = canvas.clientHeight || 400;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#1e1e1e"; ctx.fillRect(0,0,w,h);
  }
  function drawButton(x,y,w,h,label,disabled){
    const r=12;
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
    ctx.fillStyle = disabled ? "#666" : "#1565c0";
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "600 18px system-ui, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, x + w/2, y + h/2);
  }
  function drawHeader(text, y, size=22){
    const w = canvas.clientWidth || 600;
    ctx.fillStyle = "#fff";
    ctx.font = `700 ${size}px system-ui, Arial`;
    ctx.textAlign = "center"; ctx.textBaseline = "top";
    ctx.fillText(text, w/2, y);
  }
  function drawBody(text, y, size=16){
    const w = canvas.clientWidth || 600;
    ctx.fillStyle = "#ddd";
    ctx.font = `${size}px system-ui, Arial`;
    ctx.textAlign = "center"; ctx.textBaseline = "top";
    wrapText(text, w/2, y, Math.min(w*0.9, 560), size+6);
  }
  function wrapText(text, x, y, maxW, lineH){
    if (!text) return;
    const words = String(text).split(/\s+/);
    let line = "", yy = y;
    for (let n=0; n<words.length; n++){
      const test = line ? (line + " " + words[n]) : words[n];
      const w = ctx.measureText(test).width;
      if (w > maxW && n > 0){
        ctx.fillText(line, x, yy);
        line = words[n]; yy += lineH;
      } else {
        line = test;
      }
    }
    ctx.fillText(line, x, yy);
  }
  function cyclePicker(delta){
    const len = CLASS_ORDER.length;
    if (!len) return;
    classPickerIndex = (classPickerIndex + delta + len) % len;
    render();
  }
  function fmtSeconds(ms){ const s = Math.ceil(ms / 1000); return Math.max(0, s).toString(); }
  function drawTimerOverlay(){
    if (!isVoting(serverScene)) return;
    const w = canvas.clientWidth || 600;
    const pad = 16;
    const label = `⏱ ${fmtSeconds(timerRemainingMs)}s`;
    ctx.font = "700 18px system-ui, Arial";
    const tw = ctx.measureText(label).width + 16;
    const th = 28;
    const x = w - pad - tw, y = pad, r = 10;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+tw-r,y); ctx.quadraticCurveTo(x+tw,y,x+tw,y+r);
    ctx.lineTo(x+tw,y+th-r); ctx.quadraticCurveTo(x+tw,y+th,x+tw-r,y+th);
    ctx.lineTo(x+r,y+th); ctx.quadraticCurveTo(x,y+th,x,y+th-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.textAlign = "right"; ctx.textBaseline = "top";
    ctx.fillText(label, w - pad - 8, pad + 5);
  }

  let buttonRects = [];

  function currentMeta(){
    return sceneList.find(s => s.index === serverIndex) || null;
  }

  function layoutTitle(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    drawHeader("Welcome!", 16, 26);
    drawBody(displayName ? `Name: ${displayName}` : "Tap 'Enter Name' to set your name", 52);

    const btnW = Math.min(w * 0.7, 420);
    const btnH = 56; const gap = 16;
    const totalH = btnH*2 + gap;
    const x = (w - btnW)/2;
    const y0 = (h - totalH)/2;

    buttonRects.push({
      x, y: y0, w: btnW, h: btnH, label: "Enter Name",
      disabled: false,
      onClick: () => {
        const val = prompt("Enter your name (max 40 chars):", displayName || "");
        if (val !== null) socket.emit("setName", { name: val });
      }
    });
    buttonRects.push({
      x, y: y0 + btnH + gap, w: btnW, h: btnH, label: "Continue to Class Select",
      disabled: false,
      onClick: () => {
        syncPickerToUser();
        localStage = "ClassSelect";
        help.textContent = "Use arrows to choose your class, then confirm.";
        render();
      }
    });
  }

  function layoutClassSelect(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    drawHeader("Select Your Class", 20, 26);

    const selectedId = currentPickerClass();
    const selectedName = CLASS_NAMES[selectedId] || `Class ${selectedId}`;

    const panelWidth = Math.min(w * 0.75, 420);
    const panelHeight = Math.min(h * 0.35, 200);
    const panelX = (w - panelWidth) / 2;
    const panelY = Math.max(70, (h - panelHeight) / 2 - 20);

    ctx.fillStyle = "#222";
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    const r = 16;
    ctx.beginPath();
    ctx.moveTo(panelX + r, panelY);
    ctx.lineTo(panelX + panelWidth - r, panelY);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY, panelX + panelWidth, panelY + r);
    ctx.lineTo(panelX + panelWidth, panelY + panelHeight - r);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY + panelHeight, panelX + panelWidth - r, panelY + panelHeight);
    ctx.lineTo(panelX + r, panelY + panelHeight);
    ctx.quadraticCurveTo(panelX, panelY + panelHeight, panelX, panelY + panelHeight - r);
    ctx.lineTo(panelX, panelY + r);
    ctx.quadraticCurveTo(panelX, panelY, panelX + r, panelY);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#fff";
    ctx.font = "700 28px system-ui, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(selectedName, w / 2, panelY + panelHeight / 2 - 10);

    ctx.font = "16px system-ui, Arial";
    ctx.fillStyle = "#bbb";
    ctx.fillText("Use ◀ ▶ to browse classes", w / 2, panelY + panelHeight - 32);

    const arrowSize = 60;
    const arrowY = panelY + panelHeight / 2 - arrowSize / 2;
    const arrowPadding = 12;

    buttonRects.push({
      x: panelX - arrowPadding - arrowSize,
      y: arrowY,
      w: arrowSize,
      h: arrowSize,
      label: "◀",
      disabled: false,
      onClick: () => cyclePicker(-1),
    });
    buttonRects.push({
      x: panelX + panelWidth + arrowPadding,
      y: arrowY,
      w: arrowSize,
      h: arrowSize,
      label: "▶",
      disabled: false,
      onClick: () => cyclePicker(1),
    });

    const confirmWidth = Math.min(w * 0.6, 360);
    const confirmX = (w - confirmWidth) / 2;
    const confirmY = panelY + panelHeight + 30;

    buttonRects.push({
      x: confirmX,
      y: confirmY,
      w: confirmWidth,
      h: 60,
      label: `Confirm ${selectedName}`,
      disabled: false,
      onClick: () => socket.emit("setClass", { classId: selectedId }),
    });

    help.textContent = "Choose your class with the arrows, then confirm.";
  }

  function layoutWaiting(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    // Flavor per Waiting index
    const entry = currentMeta();
    const flavor = entry && entry.flavor ? entry.flavor : "Please wait…";

    drawHeader("Please wait…", Math.max(16, h*0.2), 26);
    drawBody(flavor, Math.max(60, h*0.2 + 34));
    help.textContent = "Waiting for the host to start.";
  }

  function layoutEndScene() {
    //Calculate obedience heuristic
    var obedient = (internalCtr.obedience===1)?true:false;
    var colorHex = obedient?"#0ced00":"#ed0000";

    var obedientStr = "Thank you for your unwavering trust in the Palantell system. Please wait for our patients to exit before leaving. Thank you for your cooperation!";
    var disobedientStr = "Please step forward, do not resist, you have been chosen for re-education! You will now be kindly escorted for terminal processing, thank you for your cooperation!";

    var bodyText = obedient?obedientStr:disobedientStr;

    buttonRects = [];

    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    ctx.fillStyle = colorHex;
    ctx.fillRect(0, 0, w, h);

    drawHeader("Algorithmic Evaluation", Math.max(16, h*0.2), 26);
    drawBody(bodyText, Math.max(60, h*0.2 + 34));
    help.textContent = "We deeply appreciate your trust in allowing Palantell to lovingly determine who ascends to our higher standard of living and who remains for processing—all for the sake of nurturing divine harmony.";
  }

  function layoutVoting(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    const eligible = userClass && allowedClasses.includes(userClass);
    const timeUp   = timerRemainingMs <= 0;
    const myClassName = CLASS_NAMES[userClass] || userClass;

    // Question from scene meta
    const entry = currentMeta();
    const question = sceneQuestionOverride || (entry && entry.question ? entry.question : "Make your choice");

    // --- Wrapped Question Text ---
    const width = canvas.clientWidth || 600;
    ctx.fillStyle = "#fff";
    ctx.font = "700 20px system-ui, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    // Wrap with 90% width or max 520 px
    wrapText(question, width/2, 16, Math.min(w * 0.9, 520), 26);

    if (!sceneOptions.length) {
      drawBody("Awaiting instructions for your class…", Math.max(90, h * 0.45));
      if (!eligible && userClass) {
        help.textContent = `Your class (${myClassName}) is not eligible.`;
      } else if (!userClass) {
        help.textContent = "Select a class first in ClassSelect.";
      } else {
        help.textContent = "Waiting for options…";
      }
      return;
    }

    const btnW = Math.min(w * 0.8, 520)+20;
    const btnH = Math.max(44, Math.min(64, (h-160)/sceneOptions.length - 12));
    const gap = 12;
    const totalH = sceneOptions.length*btnH + (sceneOptions.length-1)*gap;
    const x = (w - btnW)/2;
    const startY = Math.max(90, (h - totalH)/2);

    sceneOptions.forEach((lab, i) => {
      buttonRects.push({
        x, y: startY + i*(btnH+gap), w: btnW, h: btnH, label: lab,
        disabled: hasVoted || !eligible || timeUp,
        onClick: () => {
          if (hasVoted || !eligible || timeUp) return;
          hasVoted = true; 
          switch(i) {
            case 0:
              internalCtr.obedience++;
              break;
            case 1:
              internalCtr.selfishness++;
              break;
            case 2:
              internalCtr.sacrifice++;
              break;
            default:
          }
          render();
          socket.emit("vote", { optionIndex: i });
        }
      });
    });

    if (!userClass)       help.textContent = "Select a class first in ClassSelect.";
    else if (!eligible)   help.textContent = `Your class (${myClassName}) is not eligible.`;
    else if (timeUp)      help.textContent = "Time's up — waiting for next round.";
    else if (hasVoted)    help.textContent = "Vote submitted — buttons locked.";
    else                  help.textContent = "Tap an option to vote.";
  }

  function render(){
    clear();
    if (localStage === "Title") {
      layoutTitle();
    } else if (localStage === "ClassSelect") {
      layoutClassSelect();
    } else if (localStage === "Waiting") {
      if (isVoting(serverScene) && sceneOptions.length) {
        layoutVoting(); drawTimerOverlay();
      } else {
        layoutWaiting();
      }
    } else if (localStage === "EndScene") {
      layoutEndScene();
    }
    for (const b of buttonRects) drawButton(b.x,b.y,b.w,b.h,b.label,b.disabled);
  }

  canvas.addEventListener("pointerup", (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    for (const b of buttonRects) {
      if (px >= b.x && px <= b.x+b.w && py >= b.y && py <= b.y+b.h) {
        if (!b.disabled && typeof b.onClick === "function") b.onClick();
        break;
      }
    }
  }, { passive:true });

  render();
  resizeCanvasToViewport();
</script>
