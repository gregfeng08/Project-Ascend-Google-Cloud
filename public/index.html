<!doctype html>
<meta charset="utf-8" />
<title>Client</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<link rel="stylesheet" href="https://use.typekit.net/ake2rry.css">
<style>
  :root { color-scheme: light dark; }

  html, body { height: 100%; margin: 0; }

  /* Desktop / tablet: center everything */
  body {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #111;
    color: #eee;
    font-family: "bitcount-mono-double-square", system-ui;
    font-weight: 400;
    font-style: normal;
    padding: env(safe-area-inset-top) 8px env(safe-area-inset-bottom);
  }

  /* Mobile: turn off flex-centering, allow scroll */
  @media (max-width: 700px) {
    html, body {
      height: auto;  /* stop forcing 100% viewport height */
    }

    body {
      display: block;  /* no flex-centering on mobile */
      padding: env(safe-area-inset-top) 8px env(safe-area-inset-bottom);
    }

    #wrap {
      max-width: 100%;
      margin: 0 auto;
      text-align: center;
    }
  }

  #wrap { width: 100%; max-width: 900px; text-align: center; position: relative; }
  canvas { background:#1e1e1e; border:1px solid #333; border-radius:12px; touch-action: manipulation; }
  /* Connection indicator */
  #connStatus {
    position: absolute;
    top: 8px; right: 12px;
    display: flex; align-items: center; gap: 6px;
    font-size: 14px; opacity: .9;
    user-select: none;
  }
  #connDot {
    width: 12px; height: 12px;
    border-radius: 50%;
    background-color: red;
    box-shadow: 0 0 4px rgba(0,0,0,.5);
  }
  @keyframes pulseRed {
    0%   { background-color: #900; transform: scale(1);   box-shadow: 0 0 6px #f00; }
    50%  { background-color: #f00; transform: scale(1.3); box-shadow: 0 0 10px #f55; }
    100% { background-color: #900; transform: scale(1);   box-shadow: 0 0 6px #f00; }
  }
  .pulse { animation: pulseRed 1.2s infinite ease-in-out; }

  .hint { opacity:.85; font-size:14px; margin-top:8px; }

  #nameEntry {
    position: absolute;
    display: none;
    align-items: center;
    gap: 8px;
    padding: 0;
    z-index: 5;
  }
  #nameEntry input {
    text-align: center;
    flex: 1;
    min-width: 0;
    padding: 8px 12px;
    font-size: 16px;
    border-radius: 8px;
    border: 1px solid #555;
    background: #1c1c1c;
    color: #fafafa;
    height: 100%;
    box-sizing: border-box;
  }
  #nameEntry button {
    display: none;
  }
</style>

<div id="wrap">
  <div id="connStatus">
    <div id="connDot"></div><span id="connText">Connecting…</span>
  </div>
  <h1 style="margin:0 0 8px;">Client</h1>
  <p>Server scene: <strong id="serverScene">Waiting</strong></p>
  <p>Your class: <strong id="classEl">not selected</strong></p>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="nameEntry">
    <input id="nameInput" type="text" maxlength="40" placeholder="Enter your name" autocomplete="off" />
    <button id="nameSave">Save Name</button>
  </div>
  <p id="help" class="hint">Enter your name, then choose a class to join.</p>
  <p id="status" style="opacity:.7;margin-top:10px;">&nbsp;</p>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const connDot  = document.getElementById("connDot");
  const connText = document.getElementById("connText");
  const statusEl = document.getElementById("status");
  const serverSceneEl = document.getElementById("serverScene");
  const classLabel = document.getElementById("classEl");
  const wrap = document.getElementById("wrap");
  const help = document.getElementById("help");
  const nameEntry = document.getElementById("nameEntry");
  const nameInput = document.getElementById("nameInput");
  

  // ----- localStorage keys + helpers -----
  const STORAGE_KEYS = {
    name: "name",
    class: "class",
    selections: "selections", // JSON: { [sceneName]: optionIndex }
  };

  let selectionHistory = {}; // sceneName -> optionIndex
  let autoJoinFromStorage = false; // if true, we’ll auto-join on connect

  // Client local pipeline: Title -> ClassSelect -> Waiting
  let localStage = "Title";
  let displayName = "";
  let userClass = null;
  let nameInputFocused = false;
  let keyboardOpen = false;
  let baselineVH = null;   // "normal" viewport height (no keyboard)

  function loadPersistedState() {
    // name
    const savedName = localStorage.getItem(STORAGE_KEYS.name);
    if (savedName) {
      displayName = savedName;
      nameInput.value = savedName;
    }

    // class
    const savedClass = localStorage.getItem(STORAGE_KEYS.class);
    if (savedClass) {
      const cls = Number(savedClass);
      if ([1, 2, 3, 4, 5].includes(cls)) {
        userClass = cls;
        classLabel.textContent = CLASS_NAMES[cls] || "not selected";
      }
    }

    // selections
    const savedSelections = localStorage.getItem(STORAGE_KEYS.selections);
    if (savedSelections) {
      try {
        selectionHistory = JSON.parse(savedSelections) || {};
      } catch {
        selectionHistory = {};
      }
    }

    // If we have BOTH a name and a class, skip Title/ClassSelect
    if (displayName && userClass) {
      autoJoinFromStorage = true;
      localStage = "Waiting";
    }
  }

  nameInput.addEventListener("focus", () => {
    nameInputFocused = true;
    render();          // re-layout title with biased position
  });

  nameInput.addEventListener("blur", () => {
    nameInputFocused = false;
    keyboardOpen = false; // definitely no keyboard if blurred
    render();          // re-layout title back to original spot
  });

  const CLASS_NAMES = {
    1: "Bard",
    2: "Druid",
    3: "Rogue",
    4: "Wizard",
    5: "Paladin",
  };
  const CLASS_ORDER = [1,2,3,4,5];

  // Image assets (paths relative to /public)
  const IMG_BACKGROUND_FOREST   = "Images/Backgrounds/updatedforest(big).png";
  const IMG_BARD_STATIC         = "Images/Characters/Large_BardStatic.png";
  const IMG_DRUID_STATIC        = "Images/Characters/Large_DruidStatic.png";
  const IMG_ROGUE_STATIC        = "Images/Characters/Large_RogueStatic.png";
  const IMG_WIZARD_STATIC       = "Images/Characters/Large_WizardStatic.png";
  const IMG_PALADIN_STATIC      = "Images/Characters/Large_PaladinStatic.png";
  const IMG_ARROW_LEFT          = "Images/UI/Large_ArrowUI.png";
  const IMG_ARROW_RIGHT         = "Images/UI/Large_ArrowUI2.png";
  const IMG_BANNER              = "Images/UI/Large_BannerUI.png";
  const IMG_FRAME_SELECT        = "Images/UI/Large_SelectUI.png";
  const IMG_SELECT_HOVER        = "Images/UI/Large_SelectHover.png";
  const IMG_BUTTON_LONG         = "Images/UI/Large_LongUI.png";
  const IMG_OPTION_CARD         = "Images/UI/Large_Optionui.png";
  const IMG_BACKGROUND_PANEL    = "Images/UI/Large_BKGui.png";
  const IMG_STAT_PANEL          = "Images/UI/Large_StatUI.png";

  const CLASS_IMAGES = {
    1: IMG_BARD_STATIC,
    2: IMG_DRUID_STATIC,
    3: IMG_ROGUE_STATIC,
    4: IMG_WIZARD_STATIC,
    5: IMG_PALADIN_STATIC,
  };

  const classImageCache = {};

  for (const [id, src] of Object.entries(CLASS_IMAGES)) {
    const img = new Image();
    img.src = src;
    classImageCache[id] = img;
  }

  var internalCtr = {obedience:0,selfishness:0,sacrifice:0};

  const socket = io();
  socket.emit("identify", { role: "client" });

  socket.on("resetClientCache", () => {
    try {
      localStorage.removeItem("name");
      localStorage.removeItem("class");
      localStorage.removeItem("selections");

      internalCtr = {obedience:0,selfishness:0,sacrifice:0};
    } catch (e) {
      console.warn("Failed to clear localStorage", e);
    }
    // Force a full reload so the flow restarts from Title/ClassSelect
    location.reload();
  });

  // Connection indicator behavior
  socket.on("connect", () => {
    connDot.style.backgroundColor = "limegreen";
    connDot.classList.remove("pulse");
    connText.textContent = "Connected";
    statusEl.textContent = "Connected: " + socket.id;

    if (displayName) {
      socket.emit("setName", { name: displayName });
    }
    if (autoJoinFromStorage && userClass) {
      socket.emit("setClass", { classId: userClass });
      // your existing "classSet" handler will then:
      // - set localStage = "Waiting"
      // - emit joinAfterClass
      // - applySceneDataForUser + render()
    }
  });
  socket.on("disconnect", () => {
    connDot.style.backgroundColor = "#900";
    connDot.classList.add("pulse");
    connText.textContent = "Disconnected — retrying…";
    statusEl.textContent = "Disconnected… (auto-retrying)";
  });
  socket.on("reconnect", (attempt) => {
    connDot.style.backgroundColor = "limegreen";
    connDot.classList.remove("pulse");
    connText.textContent = "Reconnected (attempt " + attempt + ")";
    setTimeout(() => connText.textContent = "Connected", 2000);
  });

  // Scenes + meta from server
  let sceneList = [];   // [{index,name,type,question,flavor}, ...]
  let serverScene = "Waiting";
  let serverIndex = 0;

  // Voting state
  let hasVoted = false;
  let sceneOptions = [];
  let allowedClasses = [];
  let currentSceneData = null;
  let sceneQuestionOverride = null;
  let classPickerIndex = 0;

  // Timer
  let timerRemainingMs = 0;
  let timerDurationMs  = 30_000;

  // Receive scenes (with meta)
  socket.on("scenes", ({ scenes }) => {
    sceneList = scenes.slice();
  });

  let pendingClassSelect = false;

  function submitNameEntry({ requestClassSelect = false } = {}){
    if (localStage !== "Title") return;
    const val = (nameInput.value || "").trim();
    if (!val) {
      help.textContent = "Enter your name before continuing.";
      return;
    }
    if (requestClassSelect) pendingClassSelect = true;
    socket.emit("setName", { name: val });
  }

  // Title name set
  socket.on("nameSet", ({ ok, name }) => {
    if (ok) {
      displayName = name || "";
      nameInput.value = displayName;

      // persist name
      localStorage.setItem(STORAGE_KEYS.name, displayName);

      help.textContent = `Name set to ${displayName}. Choose your class when ready.`;
      if (pendingClassSelect) {
        pendingClassSelect = false;
        goToClassSelect();
      } else {
        render();
      }
    }
  });
  // Class select
  socket.on("classSet", ({ classId }) => {
    userClass = classId;
    syncPickerToUser();
    const name = CLASS_NAMES[classId] || `Class ${classId}`;
    classLabel.textContent = name;

    // persist class
    localStorage.setItem(STORAGE_KEYS.class, String(classId));

    localStage = "Waiting";
    help.textContent = `You are a ${name}. Waiting for the show to start…`;
    socket.emit("joinAfterClass");
    applySceneDataForUser();
    render();
  });
  // State updates (include index so we can read flavor/question)
  socket.on("state", ({ state, index }) => {
    const prevScene = serverScene;
    serverScene = state; 
    serverIndex = Number.isInteger(index) ? index : serverIndex;
    serverSceneEl.textContent = state;

    if (state === "EndScene") {
      localStage = "EndScene";
    } else if (localStage === "EndScene") {
      localStage = "Waiting";
    }

    if (state !== prevScene) {
      hasVoted = false;
      currentSceneData = null;
      sceneQuestionOverride = null;
      sceneOptions = [];
      allowedClasses = [];
    } else if (localStage === "Waiting" && isVoting(serverScene)) {
      hasVoted = false;
    }

    render();
  });

  function copyList(list){ return Array.isArray(list) ? list.slice() : []; }
  function findGroupForUser(data){
    if (!data || !Array.isArray(data.groups) || !userClass) return null;
    return data.groups.find(g => Array.isArray(g.allowedClasses) && g.allowedClasses.includes(userClass)) || null;
  }
  function currentPickerClass(){
    return CLASS_ORDER[classPickerIndex] || CLASS_ORDER[0];
  }
  function syncPickerToUser(){
    if (userClass && CLASS_ORDER.includes(userClass)) {
      classPickerIndex = CLASS_ORDER.indexOf(userClass);
    } else if (classPickerIndex < 0 || classPickerIndex >= CLASS_ORDER.length) {
      classPickerIndex = 0;
    }
  }
  function applySceneDataForUser(){
    if (!currentSceneData || currentSceneData.name !== serverScene) return;
    if (currentSceneData.multi) {
      const group = findGroupForUser(currentSceneData);
      if (group) {
        sceneOptions = Array.isArray(group.options) ? group.options.slice() : [];
        allowedClasses = copyList(group.allowedClasses);
        sceneQuestionOverride = group.question || null;
      } else {
        sceneOptions = [];
        allowedClasses = copyList(currentSceneData.allowedClasses);
        sceneQuestionOverride = currentSceneData.name === "DruidRogueTrial"
          ? "filler text DruidRogue"
          : null;
      }
    } else {
      sceneOptions = Array.isArray(currentSceneData.options) ? currentSceneData.options.slice() : [];
      allowedClasses = copyList(currentSceneData.allowedClasses);
      sceneQuestionOverride = currentSceneData.question || null;
    }
  }

  socket.on("sceneData", (payload) => {
    if (payload.name !== serverScene) return;
    currentSceneData = payload;
    applySceneDataForUser();
    render();
  });

  socket.on("sceneReset", ({ scene }) => {
    if (scene === serverScene) { hasVoted = false; render(); }
  });

  socket.on("timer", ({ remainingMs, durationMs }) => {
    timerRemainingMs = remainingMs; timerDurationMs = durationMs; render();
  });

  socket.on("notEligible", ({ scene, required }) => {
    if (scene === serverScene) {
      const pretty = required.map(c => CLASS_NAMES[c] || c).join(", ");
      help.textContent = `Not eligible. Allowed classes: ${pretty}`;
      setTimeout(() => { if (help.textContent.startsWith("Not eligible")) help.textContent = ""; }, 2500);
    }
  });

  function isVoting(name){
    return name !== "Waiting" && name !== "EndScene";
  }

  // Canvas + layout
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const ASPECT = 3/2;

  function getViewportSize(){
    const vv = window.visualViewport;
    return { vw: vv ? vv.width : innerWidth, vh: vv ? vv.height : innerHeight };
  }
  function resizeCanvasToViewport() {
    const { vw, vh } = getViewportSize();
    const isMobile = vw <= 700;

    // Track the largest viewport height we've seen as "no-keyboard" baseline
    if (baselineVH === null || vh > baselineVH) {
      baselineVH = vh;
    }

    // Detect keyboard: viewport shrunk significantly while input is focused
    if (isMobile && nameInputFocused && baselineVH) {
      const diff = baselineVH - vh;
      const KEYBOARD_THRESHOLD = 80; // px difference we consider "keyboard up"
      keyboardOpen = diff > KEYBOARD_THRESHOLD;
    } else {
      keyboardOpen = false;
    }

    let cssW, cssH;

    if (isMobile) {
      cssW = vw - 16;
      cssH = Math.min(vh * 0.75, 600);
    } else {
      const maxW = Math.min(vw * 0.98, 900);
      const maxH = Math.min(vh * 0.9, 900);

      cssW = maxW;
      cssH = cssW / ASPECT;
      if (cssH > maxH) {
        cssH = maxH;
        cssW = cssH * ASPECT;
      }
    }

    canvas.style.width  = cssW + "px";
    canvas.style.height = cssH + "px";

    fitForDPR();
    render();
  }

  function fitForDPR(){
    const dpr = devicePixelRatio || 1;
    const cssW = canvas.clientWidth || canvas.width;
    const cssH = canvas.clientHeight || canvas.height;
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  function getUiScale(mult = 1.0) {
    const w = canvas.clientWidth || window.innerWidth;

    const isMobile = w < 700;

    if (!isMobile) return 1.0;

    return mult;
  }

  let rafReq = null;
  function scheduleResize(){
    if (rafReq) return;
    rafReq = requestAnimationFrame(() => { rafReq = null; resizeCanvasToViewport(); });
  }
  addEventListener("resize", scheduleResize, { passive:true });
  if (visualViewport){
    visualViewport.addEventListener("resize", scheduleResize, { passive:true });
    visualViewport.addEventListener("scroll", scheduleResize, { passive:true });
  }

  // Drawing helpers
  function clear(){
    const w = canvas.clientWidth || 600, h = canvas.clientHeight || 400;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#1e1e1e"; ctx.fillRect(0,0,w,h);
  }
  function drawButton(x, y, w, h, label, disabled, mult = 1.0) {
    const r = 12;

    // --- button shape ---
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fillStyle = disabled ? "#666" : "#1565c0";
    ctx.fill();

    // --- dynamic text size ---
    const baseSize = 18 * getUiScale(mult);       // starting size
    const minSize  = 10 * getUiScale(mult);       // don't go smaller than this
    const paddingX = 16;                          // left/right padding inside button

    let fontSize = baseSize;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Set initial font and measure
    ctx.font = `600 ${fontSize}px system-ui, Arial`;
    const maxTextWidth = w - paddingX;
    let metrics = ctx.measureText(label);

    // If it's too wide, shrink proportionally
    if (metrics.width > maxTextWidth) {
      const scale = maxTextWidth / metrics.width; // how much to shrink
      fontSize = Math.max(minSize, fontSize * scale);
      ctx.font = `600 ${fontSize}px system-ui, Arial`;
    }

    ctx.fillStyle = "#fff";
    ctx.fillText(label, x + w / 2, y + h / 2);
  }

  function drawHeader(text, y, size=22, mult=1.0){
    const w = canvas.clientWidth || 600;
    const s = size * getUiScale(mult);
    ctx.fillStyle = "#fff";
    ctx.font = `700 ${s}px system-ui, Arial`;
    ctx.textAlign = "center"; ctx.textBaseline = "top";

    // outline
    ctx.lineWidth = 4;
    ctx.strokeStyle = "black";
    ctx.strokeText(text, w/2, y);

    ctx.fillStyle = "#fff";
    ctx.fillText(text, w/2, y);
  }
  function drawBody(text, y, size = 16, mult = 1.0){
    const w = canvas.clientWidth || 600;
    const s = size * getUiScale(mult);
    const lineH = s + 6 * getUiScale(mult);

    ctx.font = `${s}px system-ui, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    // For wrapping, stroke each line manually
    const words = String(text).split(/\s+/);
    let line = "";
    let yy = y;
    const maxW = Math.min(w * 0.9, 560);

    for (let n = 0; n < words.length; n++){
      const test = line ? (line + " " + words[n]) : words[n];
      if (ctx.measureText(test).width > maxW && n > 0){
        // outline
        ctx.lineWidth = 4;
        ctx.strokeStyle = "black";
        ctx.strokeText(line, w/2, yy);

        // fill
        ctx.fillStyle = "#fff";
        ctx.fillText(line, w/2, yy);

        line = words[n];
        yy += lineH;
      } else line = test;
    }

    // final line
    ctx.lineWidth = 4;
    ctx.strokeStyle = "black";
    ctx.strokeText(line, w/2, yy);

    ctx.fillStyle = "#fff";
    ctx.fillText(line, w/2, yy);
  }

  function wrapText(text, x, y, maxW, lineH){
    if (!text) return;
    const words = String(text).split(/\s+/);
    let line = "", yy = y;
    for (let n=0; n<words.length; n++){
      const test = line ? (line + " " + words[n]) : words[n];
      const w = ctx.measureText(test).width;
      if (w > maxW && n > 0){
        ctx.fillText(line, x, yy);
        line = words[n]; yy += lineH;
      } else {
        line = test;
      }
    }
    ctx.fillText(line, x, yy);
  }
  function cyclePicker(delta){
    const len = CLASS_ORDER.length;
    if (!len) return;
    classPickerIndex = (classPickerIndex + delta + len) % len;
    render();
  }
  function fmtSeconds(ms){ const s = Math.ceil(ms / 1000); return Math.max(0, s).toString(); }
  function drawTimerOverlay(){
    if (!isVoting(serverScene)) return;
    const w = canvas.clientWidth || 600;
    const pad = 16;
    const label = `⏱ ${fmtSeconds(timerRemainingMs)}s`;
    ctx.font = "700 18px system-ui, Arial";
    const tw = ctx.measureText(label).width + 16;
    const th = 28;
    const x = w - pad - tw, y = pad, r = 10;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+tw-r,y); ctx.quadraticCurveTo(x+tw,y,x+tw,y+r);
    ctx.lineTo(x+tw,y+th-r); ctx.quadraticCurveTo(x+tw,y+th,x+tw-r,y+th);
    ctx.lineTo(x+r,y+th); ctx.quadraticCurveTo(x,y+th,x,y+th-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.textAlign = "right"; ctx.textBaseline = "top";
    ctx.fillText(label, w - pad - 8, pad + 5);
  }

  let buttonRects = [];
  let latestNameEntryRect = null;

  function currentMeta(){
    return sceneList.find(s => s.index === serverIndex) || null;
  }

  function layoutTitle(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    drawHeader("Welcome to Project: Ascend", 56, 26);
    const intro = displayName
      ? `Name: ${displayName}`
      : "Use the text field below to enter your name before continuing.";
    drawBody(intro, 102);

    const entryW = Math.min(w * 0.7, 420);
    const entryH = 56;
    const gap = 16;
    const confirmW = Math.min(entryW / 2, 210);
    const confirmH = entryH / 2;
    const totalH = entryH + gap + confirmH;
    const entryX = (w - entryW)/2;

    let entryY;
    if (keyboardOpen) {
      // Keyboard actually up → bias near bottom of canvas
      entryY = h - totalH - 24;
    } else {
      // Default: center, like original behavior
      entryY = (h - totalH) / 2;
    }

    entryY = Math.max(entryY, 80);  // safety on tiny screens

    const confirmX = (w - confirmW)/2;
    const confirmY = entryY + entryH + gap;

    latestNameEntryRect = { x: entryX, y: entryY, w: entryW, h: entryH };

    buttonRects.push({
      x: confirmX, y: confirmY, w: confirmW, h: confirmH, label: "Confirm",
      disabled: false,
      onClick: () => {
        const val = (nameInput.value || "").trim();
        if (!val) {
          help.textContent = "Enter your name before continuing.";
          return;
        }
        if (!displayName || val !== displayName) {
          submitNameEntry({ requestClassSelect: true });
          return;
        }
        goToClassSelect();
      }
    });
  }

  function goToClassSelect(){
    syncPickerToUser();
    localStage = "ClassSelect";
    help.textContent = "Use arrows to choose your class, then confirm.";
    render();
  }

  function layoutClassSelect(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    drawHeader("Select Your Class", 20, 26);

    const selectedId   = currentPickerClass();
    const selectedName = CLASS_NAMES[selectedId] || `Class ${selectedId}`;

    // --- PANEL SIZE / POSITION ---
    const panelWidth  = Math.min(w * 0.8, 420);
    const panelHeight = Math.min(h * 0.55, 360);   // tall enough for sprite + text
    const panelX      = (w - panelWidth) / 2;
    const panelY      = Math.max(70, (h - panelHeight) / 2 - 10);

    // --- PANEL DRAW ---
    ctx.fillStyle = "#222";
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    const r = 16;
    ctx.beginPath();
    ctx.moveTo(panelX + r, panelY);
    ctx.lineTo(panelX + panelWidth - r, panelY);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY, panelX + panelWidth, panelY + r);
    ctx.lineTo(panelX + panelWidth, panelY + panelHeight - r);
    ctx.quadraticCurveTo(panelX + panelWidth, panelY + panelHeight, panelX + panelWidth - r, panelY + panelHeight);
    ctx.lineTo(panelX + r, panelY + panelHeight);
    ctx.quadraticCurveTo(panelX, panelY + panelHeight, panelX, panelY + panelHeight - r);
    ctx.lineTo(panelX, panelY + r);
    ctx.quadraticCurveTo(panelX, panelY, panelX + r, panelY);
    ctx.fill();
    ctx.stroke();

    // --- CONTENT AREA INSIDE PANEL ---
    const contentTop    = panelY + 20;
    const contentBottom = panelY + panelHeight - 20;
    const nameY         = contentBottom - 20; // class name just above bottom padding

    // --- CHARACTER IMAGE (NO OVERLAP) ---
    const img = classImageCache[selectedId];
    if (img && img.complete) {
      const aspect = img.height / img.width || 1;

      const maxImgHeight = (nameY - 12) - contentTop; // space reserved for sprite
      let   imgH         = maxImgHeight;
      let   imgW         = imgH / aspect;

      const maxImgWidth  = panelWidth * 0.55;
      if (imgW > maxImgWidth) {
        imgW = maxImgWidth;
        imgH = imgW * aspect;
        if (imgH > maxImgHeight) {
          imgH = maxImgHeight;
          imgW = imgH / aspect;
        }
      }

      const ix = (w - imgW) / 2;
      const iy = contentTop + (maxImgHeight - imgH) / 2;
      ctx.drawImage(img, ix, iy, imgW, imgH);
    }

    // --- CLASS NAME BELOW SPRITE ---
    ctx.fillStyle   = "#fff";
    ctx.font        = "700 24px system-ui, Arial";
    ctx.textAlign   = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(selectedName, w / 2, nameY);

    // --- ARROW BUTTONS (VERTICALLY CENTERED TO PANEL) ---
    const isMobile     = w < 700;
    const arrowSize    = isMobile ? 40 : 56;  // smaller arrows on mobile
    const arrowPadding = isMobile ? 4  : 8;
    const arrowY       = panelY + panelHeight / 2 - arrowSize / 2;

    // Start with your original outside positions
    let leftX  = panelX - arrowPadding - arrowSize;
    let rightX = panelX + panelWidth + arrowPadding;

    // Clamp so they don't go offscreen
    if (leftX < 4) leftX = 4;
    if (rightX + arrowSize > w - 4) rightX = w - arrowSize - 4;

    buttonRects.push({
      x: leftX,
      y: arrowY,
      w: arrowSize,
      h: arrowSize,
      label: "◀",
      disabled: false,
      onClick: () => cyclePicker(-1),
    });

    buttonRects.push({
      x: rightX,
      y: arrowY,
      w: arrowSize,
      h: arrowSize,
      label: "▶",
      disabled: false,
      onClick: () => cyclePicker(1),
    });

    // --- HINT TEXT BELOW PANEL (NO LONGER OVERLAPS SPRITE) ---
    ctx.font = "16px system-ui, Arial";
    ctx.fillStyle = "#bbb";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const hintY = panelY + panelHeight + 10;
    ctx.fillText("Use ◀ ▶ to browse classes", w / 2, hintY);

    // --- CONFIRM BUTTON BELOW HINT ---
    const confirmWidth = Math.min(w * 0.6, 360);
    const confirmX     = (w - confirmWidth) / 2;
    const confirmY     = hintY + 32;

    buttonRects.push({
      x: confirmX,
      y: confirmY,
      w: confirmWidth,
      h: 60,
      label: `Confirm`,
      disabled: false,
      onClick: () => socket.emit("setClass", { classId: selectedId }),
    });

    help.textContent = "Choose your class with the arrows, then confirm.";
  }


  function layoutWaiting(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    // Flavor per Waiting index
    const entry = currentMeta();
    const flavor = entry && entry.flavor ? entry.flavor : "Please wait…";

    drawHeader("Please wait…", Math.max(16, h*0.2), 26);
    drawBody(flavor, Math.max(60, h*0.2 + 34));
    help.textContent = "Waiting for the host to start.";
  }

  function layoutEndScene() {
    //Calculate obedience heuristic
    var obedient = (internalCtr.obedience === 1);
    var colorHex = obedient ? "#05a100" : "#d60000";

    // Participant header line
    var playerTitle = `Participant ${socket.id} — ${nameInput.value || "Unknown"}`;

    var obedientStr =
      `Thank you for your unwavering trust in the Palantell system. ` +
      `Please wait for our patients to exit before leaving. Thank you for your cooperation!`;

    var disobedientStr =
      `Please raise your hand. Do not resist, you have been chosen for re-education! ` +
      `You will now be kindly escorted for terminal processing. Thank you for your cooperation!`;

    var bodyText = obedient ? obedientStr : disobedientStr;

    buttonRects = [];

    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    // Background color (green/red)
    ctx.fillStyle = colorHex;
    ctx.fillRect(0, 0, w, h);

    // Title
    drawHeader("Algorithmic Evaluation", Math.max(16, h * 0.18), 26);

    // Draw participant ID line (smaller text, slightly below header)
    ctx.fillStyle = "#fff";
    ctx.font = "700 18px system-ui, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    ctx.fillText(playerTitle, w / 2, Math.max(16, h * 0.18) + 36);

    // Body text — shifted down to avoid overlap
    drawBody(bodyText, Math.max(16, h * 0.18) + 80);

    help.textContent =
      "We deeply appreciate your trust in allowing Palantell to lovingly determine who ascends to our higher standard of living.";
  }

  function layoutVoting(){
    buttonRects = [];
    const w = canvas.clientWidth || 600;
    const h = canvas.clientHeight || 400;

    const eligible = userClass && allowedClasses.includes(userClass);
    const timeUp   = timerRemainingMs <= 0;
    const myClassName = CLASS_NAMES[userClass] || userClass;

    // Question from scene meta
    const entry = currentMeta();
    const question = sceneQuestionOverride || (entry && entry.question ? entry.question : "Make your choice");

    const width = canvas.clientWidth || 600;
    const isMobile = width < 700;

    const qMult  = 0.85;                           // shrink factor for mobile
    const qSize  = 20 * getUiScale(qMult);         // base 20px, scaled on mobile
    const qLineH = qSize + 6 * getUiScale(qMult);  // line spacing

    ctx.fillStyle   = "#fff";
    ctx.font        = `700 ${qSize}px system-ui, Arial`;  // <-- now uses qSize
    ctx.textAlign   = "center";
    ctx.textBaseline = "top";

    // push further down on mobile so it never touches the timer
    const questionTop = isMobile ? 72 : 40;

    // Wrap with 90% width or max 520 px
    wrapText(question, width / 2, questionTop, Math.min(w * 0.9, 520), qLineH);

    if (!sceneOptions.length) {
      drawBody("Awaiting instructions for your class…", Math.max(90, h * 0.45));
      if (!eligible && userClass) {
        help.textContent = `Your class (${myClassName}) is not eligible.`;
      } else if (!userClass) {
        help.textContent = "Select a class first in ClassSelect.";
      } else {
        help.textContent = "Waiting for options…";
      }
      return;
    }

    const btnW = Math.min(w * 0.8, 520)+20;
    const btnH = Math.max(44, Math.min(64, (h-160)/sceneOptions.length - 12));
    const gap = 12;
    const totalH = sceneOptions.length*btnH + (sceneOptions.length-1)*gap;
    const x = (w - btnW) / 2;

    // Use a lower baseline on desktop so the buttons sit further down,
    // but keep the existing behavior on mobile.
    const isMobileForButtons = (canvas.clientWidth || w) < 700;
    const baseTop = isMobileForButtons ? 90 : 130;     // desktop shifted down
    const centerOffset = isMobileForButtons ? 0 : 20;  // tiny extra push down on desktop

    const startY = Math.max(baseTop, (h - totalH) / 2 + centerOffset);

    sceneOptions.forEach((lab, i) => {
      buttonRects.push({
        x, y: startY + i*(btnH+gap), w: btnW, h: btnH, label: lab, mult: 0.6,
        disabled: hasVoted || !eligible || timeUp,
        onClick: () => {
          if (hasVoted || !eligible || timeUp) return;
          hasVoted = true; 
          switch (i) {
            case 0:
              internalCtr.obedience++;
              break;
            case 1:
              internalCtr.selfishness++;
              break;
            case 2:
              internalCtr.sacrifice++;
              break;
            default:
          }
          // persist selection for this scene
          const sceneName = serverScene || "unknown";
          selectionHistory[sceneName] = i;
          localStorage.setItem(STORAGE_KEYS.selections, JSON.stringify(selectionHistory));

          render();
          socket.emit("vote", { optionIndex: i });
        }
      });
    });

    if (!userClass)       help.textContent = "Select a class first in ClassSelect.";
    else if (!eligible)   help.textContent = `Your class (${myClassName}) is not eligible.`;
    else if (timeUp)      help.textContent = "Time's up — waiting for next round.";
    else if (hasVoted)    help.textContent = "Vote submitted — buttons locked.";
    else                  help.textContent = "Tap an option to vote.";
  }

  function render(){
    clear();
    if (localStage === "Title") {
      latestNameEntryRect = null;
      layoutTitle();
    } else if (localStage === "ClassSelect") {
      latestNameEntryRect = null;
      layoutClassSelect();
    } else if (localStage === "Waiting") {
      latestNameEntryRect = null;
      if (isVoting(serverScene) && sceneOptions.length) {
        layoutVoting(); drawTimerOverlay();
      } else {
        layoutWaiting();
      }
    } else if (localStage === "EndScene") {
      latestNameEntryRect = null;
      layoutEndScene();
    }
    for (const b of buttonRects) drawButton(b.x,b.y,b.w,b.h,b.label,b.disabled,b.mult);
    updateNameEntryVisibility();
  }

  function updateNameEntryVisibility(){
    const show = localStage === "Title";
    if (!show) {
      nameEntry.style.display = "none";
      return;
    }
    nameEntry.style.display = "flex";
    nameInput.disabled = false;
    if (displayName && nameInput.value !== displayName) {
      nameInput.value = displayName;
    }
    const rect = latestNameEntryRect;
    if (!rect) return;
    const canvasRect = canvas.getBoundingClientRect();
    const wrapRect = wrap.getBoundingClientRect();
    const cw = canvas.clientWidth || canvasRect.width;
    const ch = canvas.clientHeight || canvasRect.height;
    const scaleX = canvasRect.width / cw;
    const scaleY = canvasRect.height / ch;
    const left = canvasRect.left - wrapRect.left + rect.x * scaleX;
    const top = canvasRect.top - wrapRect.top + rect.y * scaleY;
    const width = rect.w * scaleX;
    const height = rect.h * scaleY;
    nameEntry.style.left = left + "px";
    nameEntry.style.top = top + "px";
    nameEntry.style.width = width + "px";
    nameEntry.style.height = height + "px";
  }

  canvas.addEventListener("pointerup", (e) => {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    for (const b of buttonRects) {
      if (px >= b.x && px <= b.x+b.w && py >= b.y && py <= b.y+b.h) {
        if (!b.disabled && typeof b.onClick === "function") b.onClick();
        break;
      }
    }
  }, { passive:true });

  loadPersistedState();
  render();
  resizeCanvasToViewport();
</script>
